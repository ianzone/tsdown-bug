{"version":3,"file":"object.js","names":["to: [string, unknown][]","properties: Record<PropertyKey, Record<PropertyKey, unknown>>","desc: Record<string, unknown>","obj","d: Record<PropertyKey, unknown>","descs: [PropertyKey, Record<PropertyKey, unknown>][]"],"sources":["../../src/polyfill/object.ts"],"sourcesContent":["import { isFunction, isObject, isUndefined } from '@tarojs/shared'\n\nexport function handleObjectAssignPolyfill () {\n  if (!isFunction(Object.assign)) {\n    // Must be writable: true, enumerable: false, configurable: true\n    Object.assign = function (target) { // .length of function is 2\n      if (target == null) { // TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object')\n      }\n\n      const to = Object(target)\n\n      for (let index = 1; index < arguments.length; index++) {\n        const nextSource = arguments[index]\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (const nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey]\n            }\n          }\n        }\n      }\n      return to\n    }\n  }\n}\n\nexport function handleObjectEntriesPolyfill () {\n  if (!isFunction(Object.entries)) {\n    // Must be writable: true, enumerable: false, configurable: true\n    Object.entries = function (obj) { // .length of function is 2\n      if (obj == null) { // TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object')\n      }\n\n      const to: [string, unknown][] = []\n\n      if (obj != null) { // Skip over if undefined or null\n        for (const key in obj) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            to.push([key, obj[key]])\n          }\n        }\n      }\n      return to\n    }\n  }\n}\n\nexport function handleObjectDefinePropertyPolyfill () {\n  if (!isFunction(Object.defineProperties)) {\n    Object.defineProperties = function (obj, properties: Record<PropertyKey, Record<PropertyKey, unknown>>) {\n      function convertToDescriptor (desc: Record<string, unknown>) {\n        function hasProperty (obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop)\n        }\n\n        if (!isObject(desc)) { throw new TypeError('bad desc') }\n\n        const d: Record<PropertyKey, unknown> = {}\n\n        if (hasProperty(desc, 'enumerable')) d.enumerable = !!desc.enumerable\n        if (hasProperty(desc, 'configurable')) { d.configurable = !!desc.configurable }\n        if (hasProperty(desc, 'value')) d.value = desc.value\n        if (hasProperty(desc, 'writable')) d.writable = !!desc.writable\n        if (hasProperty(desc, 'get')) {\n          const g = desc.get\n\n          if (!isFunction(g) && !isUndefined(g)) { throw new TypeError('bad get') }\n          d.get = g\n        }\n        if (hasProperty(desc, 'set')) {\n          const s = desc.set\n          if (!isFunction(s) && !isUndefined(s)) { throw new TypeError('bad set') }\n          d.set = s\n        }\n\n        if (('get' in d || 'set' in d) && ('value' in d || 'writable' in d)) { throw new TypeError('identity-confused descriptor') }\n\n        return d\n      }\n\n      if (!isObject(obj)) throw new TypeError('bad obj')\n\n      properties = Object(properties)\n\n      const keys = Object.keys(properties)\n      const descs: [PropertyKey, Record<PropertyKey, unknown>][] = []\n\n      for (let i = 0; i < keys.length; i++) {\n        descs.push([keys[i], convertToDescriptor(properties[keys[i]])])\n      }\n\n      for (let i = 0; i < descs.length; i++) {\n        Object.defineProperty(obj, descs[i][0], descs[i][1])\n      }\n\n      return obj\n    }\n  }\n}\n"],"mappings":";;;;;AAEA,SAAgB,6BAA8B;AAC5C,MAAK,iCAAW,OAAO,OAAO,EAAE;AAE9B,SAAO,SAAS,SAAU,QAAQ;AAChC,OAAI,UAAU,MAAM;AAClB,UAAM,IAAI,UAAU;GACrB;GAED,MAAM,KAAK,OAAO,OAAO;AAEzB,QAAK,IAAI,QAAQ,GAAG,QAAQ,UAAU,QAAQ,SAAS;IACrD,MAAM,aAAa,UAAU;AAE7B,QAAI,cAAc,MAAM;AACtB,UAAK,MAAM,WAAW,YAAY;AAEhC,UAAI,OAAO,UAAU,eAAe,KAAK,YAAY,QAAQ,EAAE;AAC7D,UAAG,WAAW,WAAW;MAC1B;KACF;IACF;GACF;AACD,UAAO;EACR;CACF;AACF;AAED,SAAgB,8BAA+B;AAC7C,MAAK,iCAAW,OAAO,QAAQ,EAAE;AAE/B,SAAO,UAAU,SAAU,KAAK;AAC9B,OAAI,OAAO,MAAM;AACf,UAAM,IAAI,UAAU;GACrB;GAED,MAAMA,KAA0B,CAAE;AAElC,OAAI,OAAO,MAAM;AACf,SAAK,MAAM,OAAO,KAAK;AAErB,SAAI,OAAO,UAAU,eAAe,KAAK,KAAK,IAAI,EAAE;AAClD,SAAG,KAAK,CAAC,KAAK,IAAI,IAAK,EAAC;KACzB;IACF;GACF;AACD,UAAO;EACR;CACF;AACF;AAED,SAAgB,qCAAsC;AACpD,MAAK,iCAAW,OAAO,iBAAiB,EAAE;AACxC,SAAO,mBAAmB,SAAU,KAAKC,YAA+D;GACtG,SAAS,oBAAqBC,MAA+B;IAC3D,SAAS,YAAaC,OAAK,MAAM;AAC/B,YAAO,OAAO,UAAU,eAAe,KAAKA,OAAK,KAAK;IACvD;AAED,SAAK,+BAAS,KAAK,EAAE;AAAE,WAAM,IAAI,UAAU;IAAa;IAExD,MAAMC,IAAkC,CAAE;AAE1C,QAAI,YAAY,MAAM,aAAa,CAAE,GAAE,eAAe,KAAK;AAC3D,QAAI,YAAY,MAAM,eAAe,EAAE;AAAE,OAAE,iBAAiB,KAAK;IAAc;AAC/E,QAAI,YAAY,MAAM,QAAQ,CAAE,GAAE,QAAQ,KAAK;AAC/C,QAAI,YAAY,MAAM,WAAW,CAAE,GAAE,aAAa,KAAK;AACvD,QAAI,YAAY,MAAM,MAAM,EAAE;KAC5B,MAAM,IAAI,KAAK;AAEf,UAAK,iCAAW,EAAE,KAAK,kCAAY,EAAE,EAAE;AAAE,YAAM,IAAI,UAAU;KAAY;AACzE,OAAE,MAAM;IACT;AACD,QAAI,YAAY,MAAM,MAAM,EAAE;KAC5B,MAAM,IAAI,KAAK;AACf,UAAK,iCAAW,EAAE,KAAK,kCAAY,EAAE,EAAE;AAAE,YAAM,IAAI,UAAU;KAAY;AACzE,OAAE,MAAM;IACT;AAED,SAAK,SAAS,KAAK,SAAS,OAAO,WAAW,KAAK,cAAc,IAAI;AAAE,WAAM,IAAI,UAAU;IAAiC;AAE5H,WAAO;GACR;AAED,QAAK,+BAAS,IAAI,CAAE,OAAM,IAAI,UAAU;AAExC,gBAAa,OAAO,WAAW;GAE/B,MAAM,OAAO,OAAO,KAAK,WAAW;GACpC,MAAMC,QAAuD,CAAE;AAE/D,QAAK,IAAI,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,KAAK,CAAC,KAAK,IAAI,oBAAoB,WAAW,KAAK,IAAI,AAAC,EAAC;GAChE;AAED,QAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,WAAO,eAAe,KAAK,MAAM,GAAG,IAAI,MAAM,GAAG,GAAG;GACrD;AAED,UAAO;EACR;CACF;AACF"}