{"version":3,"file":"intersection-observer.js","names":["registry: number[]","entry: IntersectionObserverEntry","callback: IntersectionObserverCallback","options: IntersectionObserverInit","parentComputedStyle: Partial<CSSStyleDeclaration>","newRect: Record<string, number>"],"sources":["../../src/polyfill/intersection-observer.ts"],"sourcesContent":["/* eslint-disable eqeqeq */\nimport { isFunction, isNumber } from '@tarojs/shared';\n\nimport { throttle } from '../utils';\n\nexport function handleIntersectionObserverPolyfill() {\n  // Exit early if all IntersectionObserver and IntersectionObserverEntry\n  // features are natively supported.\n  if (\n    'IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype\n  ) {\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n      // Minimal polyfill for Edge 15's lack of `isIntersecting`\n      // See: https://github.com/w3c/IntersectionObserver/issues/211\n      Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {\n        get: function () {\n          return this.intersectionRatio > 0;\n        },\n      });\n    }\n  } else {\n    handleIntersectionObserverObjectPolyfill();\n  }\n}\n\nfunction handleIntersectionObserverObjectPolyfill() {\n  const document = window.document;\n\n  /**\n   * An IntersectionObserver registry. This registry exists to hold a strong\n   * reference to IntersectionObserver instances currently observing a target\n   * element. Without this registry, instances without another reference may be\n   * garbage collected.\n   */\n  const registry: number[] = [];\n\n  /**\n   * Creates the global IntersectionObserverEntry constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n   * @param {Object} entry A dictionary of instance properties.\n   * @constructor\n   */\n  function IntersectionObserverEntry(entry: IntersectionObserverEntry) {\n    this.time = entry.time;\n    this.target = entry.target;\n    this.rootBounds = entry.rootBounds;\n    this.boundingClientRect = entry.boundingClientRect;\n    this.intersectionRect = entry.intersectionRect || getEmptyRect();\n    this.isIntersecting = !!entry.intersectionRect;\n\n    // Calculates the intersection ratio.\n    const targetRect = this.boundingClientRect;\n    const targetArea = targetRect.width * targetRect.height;\n    const intersectionRect = this.intersectionRect;\n    const intersectionArea = intersectionRect.width * intersectionRect.height;\n\n    // Sets intersection ratio.\n    if (targetArea) {\n      // Round the intersection ratio to avoid floating point math issues:\n      // https://github.com/w3c/IntersectionObserver/issues/324\n      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n    } else {\n      // If area is zero and is intersecting, sets to 1, otherwise to 0\n      this.intersectionRatio = this.isIntersecting ? 1 : 0;\n    }\n  }\n\n  /**\n   * Creates the global IntersectionObserver constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n   * @param {Function} callback The function to be invoked after intersection\n   *     changes have queued. The function is not invoked if the queue has\n   *     been emptied by calling the `takeRecords` method.\n   * @param {Object=} opt_options Optional configuration options.\n   * @constructor\n   */\n  function IntersectionObserver(\n    callback: IntersectionObserverCallback,\n    options: IntersectionObserverInit = {},\n  ) {\n    if (!isFunction(callback)) {\n      throw new Error('callback must be a function');\n    }\n\n    if (options.root && options.root.nodeType != 1) {\n      throw new Error('root must be an Element');\n    }\n\n    // Binds and throttles `this._checkForIntersections`.\n    this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this),\n      this.THROTTLE_TIMEOUT,\n    );\n\n    // Private properties.\n    this._callback = callback;\n    this._observationTargets = [];\n    this._queuedEntries = [];\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n    // Public properties.\n    this.thresholds = this._initThresholds(options.threshold);\n    this.root = options.root || null;\n    this.rootMargin = this._rootMarginValues.map((margin) => margin.value + margin.unit).join(' ');\n  }\n\n  /**\n   * The minimum interval within which the document will be checked for\n   * intersection changes.\n   */\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n  /**\n   * The frequency in which the polyfill polls for intersection changes.\n   * this can be updated on a per instance basis and must be set prior to\n   * calling `observe` on the first target.\n   */\n  IntersectionObserver.prototype.POLL_INTERVAL = null;\n\n  /**\n   * Use a mutation observer on the root element\n   * to detect intersection changes.\n   */\n  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n  /**\n   * Starts observing a target element for intersection changes based on\n   * the thresholds values.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.observe = function (target) {\n    const isTargetAlreadyObserved = this._observationTargets.some((item) => item.element == target);\n\n    if (isTargetAlreadyObserved) return;\n\n    if (!(target && target.nodeType == 1)) {\n      throw new Error('target must be an Element');\n    }\n\n    this._registerInstance();\n    this._observationTargets.push({ element: target, entry: null });\n    this._monitorIntersections();\n    this._checkForIntersections();\n  };\n\n  /**\n   * Stops observing a target element for intersection changes.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.unobserve = function (target) {\n    this._observationTargets = this._observationTargets.filter((item) => item.element != target);\n    if (!this._observationTargets.length) {\n      this._unmonitorIntersections();\n      this._unregisterInstance();\n    }\n  };\n\n  /**\n   * Stops observing all target elements for intersection changes.\n   */\n  IntersectionObserver.prototype.disconnect = function () {\n    this._observationTargets = [];\n    this._unmonitorIntersections();\n    this._unregisterInstance();\n  };\n\n  /**\n   * Returns any queue entries that have not yet been reported to the\n   * callback and clears the queue. This can be used in conjunction with the\n   * callback to obtain the absolute most up-to-date intersection information.\n   * @return {Array} The currently queued entries.\n   */\n  IntersectionObserver.prototype.takeRecords = function () {\n    const records = this._queuedEntries.slice();\n    this._queuedEntries = [];\n    return records;\n  };\n\n  /**\n   * Accepts the threshold value from the user configuration object and\n   * returns a sorted array of unique threshold values. If a value is not\n   * between 0 and 1 and error is thrown.\n   * @private\n   * @param {Array|number=} opt_threshold An optional threshold value or\n   *     a list of threshold values, defaulting to [0].\n   * @return {Array} A sorted list of unique and valid threshold values.\n   */\n  IntersectionObserver.prototype._initThresholds = (opt_threshold) => {\n    let threshold = opt_threshold || [0];\n    if (!Array.isArray(threshold)) threshold = [threshold];\n\n    return threshold.sort().filter((t, i, a) => {\n      if (!isNumber(t) || isNaN(t) || t < 0 || t > 1) {\n        throw new Error('threshold must be a number between 0 and 1 inclusively');\n      }\n      return t !== a[i - 1];\n    });\n  };\n\n  /**\n   * Accepts the rootMargin value from the user configuration object\n   * and returns an array of the four margin values as an object containing\n   * the value and unit properties. If any of the values are not properly\n   * formatted or use a unit other than px or %, and error is thrown.\n   * @private\n   * @param {string=} opt_rootMargin An optional rootMargin value,\n   *     defaulting to '0px'.\n   * @return {Array<Object>} An array of margin objects with the keys\n   *     value and unit.\n   */\n  IntersectionObserver.prototype._parseRootMargin = (opt_rootMargin) => {\n    const marginString = opt_rootMargin || '0px';\n    const margins = marginString.split(/\\s+/).map((margin) => {\n      const parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n      if (!parts) {\n        throw new Error('rootMargin must be specified in pixels or percent');\n      }\n      return { value: Number.parseFloat(parts[1]), unit: parts[2] };\n    });\n\n    // Handles shorthand.\n    margins[1] = margins[1] || margins[0];\n    margins[2] = margins[2] || margins[0];\n    margins[3] = margins[3] || margins[1];\n\n    return margins;\n  };\n\n  /**\n   * Starts polling for intersection changes if the polling is not already\n   * happening, and if the page's visibility state is visible.\n   * @private\n   */\n  IntersectionObserver.prototype._monitorIntersections = function () {\n    if (!this._monitoringIntersections) {\n      this._monitoringIntersections = true;\n\n      // If a poll interval is set, use polling instead of listening to\n      // resize and scroll events or DOM mutations.\n      if (this.POLL_INTERVAL) {\n        this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL);\n      } else {\n        addEvent(window, 'resize', this._checkForIntersections, true);\n        addEvent(document, 'scroll', this._checkForIntersections, true);\n\n        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n          this._domObserver = new MutationObserver(this._checkForIntersections);\n          this._domObserver.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true,\n          });\n        }\n      }\n    }\n  };\n\n  /**\n   * Stops polling for intersection changes.\n   * @private\n   */\n  IntersectionObserver.prototype._unmonitorIntersections = function () {\n    if (this._monitoringIntersections) {\n      this._monitoringIntersections = false;\n\n      clearInterval(this._monitoringInterval);\n      this._monitoringInterval = null;\n\n      removeEvent(window, 'resize', this._checkForIntersections, true);\n      removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if (this._domObserver) {\n        this._domObserver.disconnect();\n        this._domObserver = null;\n      }\n    }\n  };\n\n  /**\n   * Scans each observation target for intersection changes and adds them\n   * to the internal entries queue. If new entries are found, it\n   * schedules the callback to be invoked.\n   * @private\n   */\n  IntersectionObserver.prototype._checkForIntersections = function () {\n    const rootIsInDom = this._rootIsInDom();\n    const rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n    this._observationTargets.forEach(function (item) {\n      const target = item.element;\n      const targetRect = getBoundingClientRect(target);\n      const rootContainsTarget = this._rootContainsTarget(target);\n      const oldEntry = item.entry;\n      const intersectionRect =\n        rootIsInDom &&\n        rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, rootRect);\n\n      const newEntry = (item.entry = new IntersectionObserverEntry({\n        time: now(),\n        target: target,\n        boundingClientRect: targetRect,\n        rootBounds: rootRect,\n        intersectionRect: intersectionRect,\n        intersectionRatio: -1,\n        isIntersecting: false,\n      }));\n\n      if (!oldEntry) {\n        this._queuedEntries.push(newEntry);\n      } else if (rootIsInDom && rootContainsTarget) {\n        // If the new entry intersection ratio has crossed any of the\n        // thresholds, add a new entry.\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n          this._queuedEntries.push(newEntry);\n        }\n      } else {\n        // If the root is not in the DOM or target is not contained within\n        // root but the previous entry for this target had an intersection,\n        // add a new record indicating removal.\n        if (oldEntry && oldEntry.isIntersecting) {\n          this._queuedEntries.push(newEntry);\n        }\n      }\n    }, this);\n\n    if (this._queuedEntries.length) {\n      this._callback(this.takeRecords(), this);\n    }\n  };\n\n  /**\n   * Accepts a target and root rect computes the intersection between then\n   * following the algorithm in the spec.\n   * TODO(philipwalton): at this time clip-path is not considered.\n   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n   * @param {Element} target The target DOM element\n   * @param {Object} rootRect The bounding rect of the root after being\n   *     expanded by the rootMargin value.\n   * @return {?Object} The final intersection rect object or undefined if no\n   *     intersection is found.\n   * @private\n   */\n  IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, rootRect) {\n    // If the element isn't displayed, an intersection can't happen.\n    if (window.getComputedStyle(target).display === 'none') return;\n\n    const targetRect = getBoundingClientRect(target);\n    let intersectionRect = targetRect;\n    let parent = getParentNode(target);\n    let atRoot = false;\n\n    while (!atRoot) {\n      let parentRect = null;\n      const parentComputedStyle: Partial<CSSStyleDeclaration> =\n        parent.nodeType == 1 ? window.getComputedStyle(parent) : {};\n\n      // If the parent isn't displayed, an intersection can't happen.\n      if (parentComputedStyle.display === 'none') return;\n\n      if (parent == this.root || parent == document) {\n        atRoot = true;\n        parentRect = rootRect;\n      } else {\n        // If the element has a non-visible overflow, and it's not the <body>\n        // or <html> element, update the intersection rect.\n        // Note: <body> and <html> cannot be clipped to a rect that's not also\n        // the document rect, so no need to compute a new intersection.\n        if (\n          parent != document.body &&\n          parent != document.documentElement &&\n          parentComputedStyle.overflow != 'visible'\n        ) {\n          parentRect = getBoundingClientRect(parent);\n        }\n      }\n\n      // If either of the above conditionals set a new parentRect,\n      // calculate new intersection data.\n      if (parentRect) {\n        intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n        if (!intersectionRect) break;\n      }\n      parent = getParentNode(parent);\n    }\n    return intersectionRect;\n  };\n\n  /**\n   * Returns the root rect after being expanded by the rootMargin value.\n   * @return {Object} The expanded root rect.\n   * @private\n   */\n  IntersectionObserver.prototype._getRootRect = function () {\n    let rootRect;\n    if (this.root) {\n      rootRect = getBoundingClientRect(this.root);\n    } else {\n      // Use <html>/<body> instead of window since scroll bars affect size.\n      const html = document.documentElement;\n      const body = document.body;\n      rootRect = {\n        top: 0,\n        left: 0,\n        right: html.clientWidth || body.clientWidth,\n        width: html.clientWidth || body.clientWidth,\n        bottom: html.clientHeight || body.clientHeight,\n        height: html.clientHeight || body.clientHeight,\n      };\n    }\n    return this._expandRectByRootMargin(rootRect);\n  };\n\n  /**\n   * Accepts a rect and expands it by the rootMargin value.\n   * @param {Object} rect The rect object to expand.\n   * @return {Object} The expanded rect.\n   * @private\n   */\n  IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {\n    const margins = this._rootMarginValues.map((margin, i) =>\n      margin.unit === 'px'\n        ? margin.value\n        : (margin.value * (i % 2 ? rect.width : rect.height)) / 100,\n    );\n    const newRect: Record<string, number> = {\n      top: rect.top - margins[0],\n      right: rect.right + margins[1],\n      bottom: rect.bottom + margins[2],\n      left: rect.left - margins[3],\n    };\n    newRect.width = newRect.right - newRect.left;\n    newRect.height = newRect.bottom - newRect.top;\n\n    return newRect;\n  };\n\n  /**\n   * Accepts an old and new entry and returns true if at least one of the\n   * threshold values has been crossed.\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n   *    particular target element or null if no previous entry exists.\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\n   *    particular target element.\n   * @return {boolean} Returns true if a any threshold has been crossed.\n   * @private\n   */\n  IntersectionObserver.prototype._hasCrossedThreshold = function (oldEntry, newEntry) {\n    // To make comparing easier, an entry that has a ratio of 0\n    // but does not actually intersect is given a value of -1\n    const oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;\n    const newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;\n\n    // Ignore unchanged ratios\n    if (oldRatio === newRatio) return;\n\n    for (let i = 0; i < this.thresholds.length; i++) {\n      const threshold = this.thresholds[i];\n\n      // Return true if an entry matches a threshold or if the new ratio\n      // and the old ratio are on the opposite sides of a threshold.\n      if (\n        threshold == oldRatio ||\n        threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio\n      ) {\n        return true;\n      }\n    }\n  };\n\n  /**\n   * Returns whether or not the root element is an element and is in the DOM.\n   * @return {boolean} True if the root element is an element and is in the DOM.\n   * @private\n   */\n  IntersectionObserver.prototype._rootIsInDom = function () {\n    return !this.root || containsDeep(document, this.root);\n  };\n\n  /**\n   * Returns whether or not the target element is a child of root.\n   * @param {Element} target The target element to check.\n   * @return {boolean} True if the target element is a child of root.\n   * @private\n   */\n  IntersectionObserver.prototype._rootContainsTarget = function (target) {\n    return containsDeep(this.root || document, target);\n  };\n\n  /**\n   * Adds the instance to the global IntersectionObserver registry if it isn't\n   * already present.\n   * @private\n   */\n  IntersectionObserver.prototype._registerInstance = function () {\n    if (registry.indexOf(this) < 0) {\n      registry.push(this);\n    }\n  };\n\n  /**\n   * Removes the instance from the global IntersectionObserver registry.\n   * @private\n   */\n  IntersectionObserver.prototype._unregisterInstance = function () {\n    const index = registry.indexOf(this);\n    if (index != -1) registry.splice(index, 1);\n  };\n\n  /**\n   * Returns the result of the performance.now() method or null in browsers\n   * that don't support the API.\n   * @return {number} The elapsed time since the page was requested.\n   */\n  function now() {\n    return window.performance && performance.now && performance.now();\n  }\n\n  /**\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n   * @param {Node} node The DOM node to add the event handler to.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to add.\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\n   *     phase. Note: this only works in modern browsers.\n   */\n  function addEvent(node, event, fn, opt_useCapture) {\n    if (isFunction(node.addEventListener)) {\n      node.addEventListener(event, fn, opt_useCapture || false);\n    } else if (isFunction(node.attachEvent)) {\n      node.attachEvent('on' + event, fn);\n    }\n  }\n\n  /**\n   * Removes a previously added event handler from a DOM node.\n   * @param {Node} node The DOM node to remove the event handler from.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to remove.\n   * @param {boolean} opt_useCapture If the event handler was added with this\n   *     flag set to true, it should be set to true here in order to remove it.\n   */\n  function removeEvent(node, event, fn, opt_useCapture) {\n    if (isFunction(node.removeEventListener)) {\n      node.removeEventListener(event, fn, opt_useCapture || false);\n    } else if (isFunction(node.detatchEvent)) {\n      node.detatchEvent('on' + event, fn);\n    }\n  }\n\n  /**\n   * Returns the intersection between two rect objects.\n   * @param {Object} rect1 The first rect.\n   * @param {Object} rect2 The second rect.\n   * @return {?Object} The intersection rect or undefined if no intersection\n   *     is found.\n   */\n  function computeRectIntersection(rect1, rect2) {\n    const top = Math.max(rect1.top, rect2.top);\n    const bottom = Math.min(rect1.bottom, rect2.bottom);\n    const left = Math.max(rect1.left, rect2.left);\n    const right = Math.min(rect1.right, rect2.right);\n    const width = right - left;\n    const height = bottom - top;\n\n    return (\n      width >= 0 &&\n      height >= 0 && {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right,\n        width: width,\n        height: height,\n      }\n    );\n  }\n\n  /**\n   * Shims the native getBoundingClientRect for compatibility with older IE.\n   * @param {Element} el The element whose bounding rect to get.\n   * @return {Object} The (possibly shimmed) rect of the element.\n   */\n  function getBoundingClientRect(el) {\n    let rect;\n\n    try {\n      rect = el.getBoundingClientRect();\n    } catch (err) {\n      // Ignore Windows 7 IE11 \"Unspecified error\"\n      // https://github.com/w3c/IntersectionObserver/pull/205\n    }\n\n    if (!rect) return getEmptyRect();\n\n    // Older IE\n    if (!(rect.width && rect.height)) {\n      rect = {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top,\n      };\n    }\n    return rect;\n  }\n\n  /**\n   * Returns an empty rect object. An empty rect is returned when an element\n   * is not in the DOM.\n   * @return {Object} The empty rect.\n   */\n  function getEmptyRect() {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0,\n    };\n  }\n\n  /**\n   * Checks to see if a parent element contains a child element (including inside\n   * shadow DOM).\n   * @param {Node} parent The parent element.\n   * @param {Node} child The child element.\n   * @return {boolean} True if the parent node contains the child node.\n   */\n  function containsDeep(parent, child) {\n    let node = child;\n    while (node) {\n      if (node == parent) return true;\n\n      node = getParentNode(node);\n    }\n    return false;\n  }\n\n  /**\n   * Gets the parent node of an element or its host element if the parent node\n   * is a shadow root.\n   * @param {Node} node The node whose parent to get.\n   * @return {Node|null} The parent node or null if no parent exists.\n   */\n  function getParentNode(node) {\n    const parent = node.parentNode;\n\n    if (parent && parent.nodeType == 11 && parent.host) {\n      // If the parent is a shadow root, return the host element.\n      return parent.host;\n    }\n\n    if (parent && parent.assignedSlot) {\n      // If the parent is distributed in a <slot>, return the parent of a slot.\n      return parent.assignedSlot.parentNode;\n    }\n\n    return parent;\n  }\n\n  // Exposes the constructors globally.\n  window.IntersectionObserver =\n    IntersectionObserver as unknown as typeof window.IntersectionObserver;\n  window.IntersectionObserverEntry =\n    IntersectionObserverEntry as unknown as typeof window.IntersectionObserverEntry;\n}\n"],"mappings":"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"}