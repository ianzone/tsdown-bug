{"version":3,"file":"node.js","names":["node: TaroNode","isClean?: boolean","index: number","refChild: TaroNode","text: string","addedNodes: TaroNode[]","newChild: T","refChild?: TaroNode | null","isReplace?: boolean","newChild: TaroNode","oldChild: TaroNode","child: T","options: RemoveChildOptions","options?: RemoveChildOptions","payload: UpdatePayload","env","methodName: string","options: TFunc | Record<string, any>"],"sources":["../../src/dom/node.ts"],"sourcesContent":["import { ensure, hooks, Shortcuts } from '@tarojs/shared'\n\nimport { DOCUMENT_FRAGMENT } from '../constants'\nimport { MutationObserver, MutationRecordType } from '../dom-external/mutation-observer'\nimport env from '../env'\nimport { hydrate } from '../hydrate'\nimport { extend, incrementId, isComment } from '../utils'\nimport { eventSource } from './event-source'\nimport { TaroEventTarget } from './event-target'\nimport { NodeType } from './node_types'\n\nimport type { TFunc, UpdatePayload } from '../interface'\nimport type { TaroDocument } from './document'\nimport type { TaroElement } from './element'\nimport type { TaroRootElement } from './root'\n\ninterface RemoveChildOptions {\n  cleanRef?: boolean\n  doUpdate?: boolean\n}\n\nconst CHILDNODES = Shortcuts.Childnodes\nconst nodeId = incrementId()\n\nexport class TaroNode extends TaroEventTarget {\n  public uid: string\n  public sid: string\n  public nodeType: NodeType\n  public nodeName: string\n  public parentNode: TaroNode | null = null\n  public childNodes: TaroNode[] = []\n\n  public constructor () {\n    super()\n    this.uid = '_' + nodeId() // dom 节点 id，开发者可修改\n    this.sid = this.uid // dom 节点全局唯一 id，不可被修改\n    eventSource.set(this.sid, this)\n  }\n\n  private hydrate = (node: TaroNode) => () => hydrate(node as TaroElement)\n\n  private updateChildNodes (isClean?: boolean) {\n    const cleanChildNodes = () => []\n    const rerenderChildNodes = () => {\n      const childNodes = this.childNodes.filter(node => !isComment(node))\n      return childNodes.map(hydrate)\n    }\n\n    this.enqueueUpdate({\n      path: `${this._path}.${CHILDNODES}`,\n      value: isClean ? cleanChildNodes : rerenderChildNodes\n    })\n  }\n\n  private updateSingleChild (index: number) {\n    this.childNodes.forEach((child, childIndex) => {\n      if (isComment(child)) return\n\n      if (index && childIndex < index) return\n\n      this.enqueueUpdate({\n        path: child._path,\n        value: this.hydrate(child)\n      })\n    })\n  }\n\n  public get _root (): TaroRootElement | null {\n    return this.parentNode?._root || null\n  }\n\n  protected findIndex (refChild: TaroNode): number {\n    const index = this.childNodes.indexOf(refChild)\n\n    ensure(index !== -1, 'The node to be replaced is not a child of this node.')\n\n    return index\n  }\n\n  public get _path (): string {\n    const parentNode = this.parentNode\n\n    if (parentNode) {\n      // 计算路径时，先过滤掉 comment 节点\n      const list = parentNode.childNodes.filter(node => !isComment(node))\n      const indexOfNode = list.indexOf(this)\n      const index = hooks.call('getPathIndex', indexOfNode)\n\n      return `${parentNode._path}.${CHILDNODES}.${index}`\n    }\n\n    return ''\n  }\n\n  public get nextSibling (): TaroNode | null {\n    const parentNode = this.parentNode\n    return parentNode?.childNodes[parentNode.findIndex(this) + 1] || null\n  }\n\n  public get previousSibling (): TaroNode | null {\n    const parentNode = this.parentNode\n    return parentNode?.childNodes[parentNode.findIndex(this) - 1] || null\n  }\n\n  public get parentElement (): TaroElement | null {\n    const parentNode = this.parentNode\n    if (parentNode?.nodeType === NodeType.ELEMENT_NODE) {\n      return parentNode as TaroElement\n    }\n    return null\n  }\n\n  public get firstChild (): TaroNode | null {\n    return this.childNodes[0] || null\n  }\n\n  public get lastChild (): TaroNode | null {\n    const childNodes = this.childNodes\n    return childNodes[childNodes.length - 1] || null\n  }\n\n  /**\n   * @textContent 目前只能置空子元素\n   * @TODO 等待完整 innerHTML 实现\n   */\n  // eslint-disable-next-line accessor-pairs\n  public set textContent (text: string) {\n    const removedNodes = this.childNodes.slice()\n    const addedNodes: TaroNode[] = []\n\n    // Handle old children' data structure & ref\n    while (this.firstChild) {\n      this.removeChild(this.firstChild, { doUpdate: false })\n    }\n\n    if (text === '') {\n      this.updateChildNodes(true)\n    } else {\n      const newText = env.document.createTextNode(text)\n      addedNodes.push(newText)\n      this.appendChild(newText)\n      this.updateChildNodes()\n    }\n\n    // @Todo: appendChild 会多触发一次\n    MutationObserver.record({\n      type: MutationRecordType.CHILD_LIST,\n      target: this,\n      removedNodes,\n      addedNodes\n    })\n  }\n\n  /**\n   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore\n   * @scenario\n   * [A,B,C]\n   *   1. insert D before C, D has no parent\n   *   2. insert D before C, D has the same parent of C\n   *   3. insert D before C, D has the different parent of C\n   */\n  public insertBefore<T extends TaroNode> (newChild: T, refChild?: TaroNode | null, isReplace?: boolean): T {\n    if (newChild.nodeName === DOCUMENT_FRAGMENT) {\n      newChild.childNodes.reduceRight((previousValue, currentValue) => {\n        this.insertBefore(currentValue, previousValue)\n        return currentValue\n      }, refChild)\n      return newChild\n    }\n\n    // Parent release newChild\n    //   - cleanRef: false (No need to clean eventSource, because newChild is about to be inserted)\n    //   - update: true (Need to update parent.childNodes, because parent.childNodes is reordered)\n    newChild.remove({ cleanRef: false })\n\n    let index = 0\n    // Data structure\n    newChild.parentNode = this\n    if (refChild) {\n      // insertBefore & replaceChild\n      index = this.findIndex(refChild)\n      this.childNodes.splice(index, 0, newChild)\n    } else {\n      // appendChild\n      this.childNodes.push(newChild)\n    }\n\n    const childNodesLength = this.childNodes.length\n    // Serialization\n    if (this._root) {\n      if (!refChild) {\n        // appendChild\n        const isOnlyChild = childNodesLength === 1\n        if (isOnlyChild) {\n          this.updateChildNodes()\n        } else {\n          this.enqueueUpdate({\n            path: newChild._path,\n            value: this.hydrate(newChild)\n          })\n        }\n      } else if (isReplace) {\n        // replaceChild\n        this.enqueueUpdate({\n          path: newChild._path,\n          value: this.hydrate(newChild)\n        })\n      } else {\n        // insertBefore 有两种更新模式\n        // 比方说有 A B C 三个节点，现在要在 C 前插入 D\n        // 1. 插入 D，然后更新整个父节点的 childNodes 数组\n        // setData({ cn: [A, B, D, C] })\n        // 2. 插入 D，然后更新 D 以及 D 之后每个节点的数据\n        // setData ({\n        //   cn.[2]: D,\n        //   cn.[3]: C,\n        // })\n        // 由于微信解析 ’cn.[2]‘ 这些路径的时候也需要消耗时间，\n        // 所以根据 insertBefore 插入的位置来做不同的处理\n        const mark = childNodesLength * 2 / 3\n        if (mark > index) {\n          // 如果 insertBefore 的位置在 childNodes 的 2/3 前，则为了避免解析路径消耗过多的时间，采用第一种方式\n          this.updateChildNodes()\n        } else {\n          // 如果 insertBefore 的位置在 childNodes 的 2/3 之后，则采用第二种方式，避免 childNodes 的全量更新\n          this.updateSingleChild(index)\n        }\n      }\n    }\n\n    MutationObserver.record({\n      type: MutationRecordType.CHILD_LIST,\n      target: this,\n      addedNodes: [newChild],\n      removedNodes: isReplace\n        ? [refChild as TaroNode] /** replaceChild */\n        : [],\n      nextSibling: isReplace\n        ? (refChild as TaroNode).nextSibling /** replaceChild */\n        : (refChild || null), /** insertBefore & appendChild */\n      previousSibling: newChild.previousSibling\n    })\n\n    return newChild\n  }\n\n  /**\n   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild\n   * @scenario\n   * [A,B,C]\n   *   1. append C, C has no parent\n   *   2. append C, C has the same parent of B\n   *   3. append C, C has the different parent of B\n   */\n  public appendChild (newChild: TaroNode) {\n    return this.insertBefore(newChild)\n  }\n\n  /**\n   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild\n   * @scenario\n   * [A,B,C]\n   *   1. replace B with C, C has no parent\n   *   2. replace B with C, C has no parent, C has the same parent of B\n   *   3. replace B with C, C has no parent, C has the different parent of B\n   */\n  public replaceChild (newChild: TaroNode, oldChild: TaroNode) {\n    if (oldChild.parentNode !== this) return\n\n    // Insert the newChild\n    this.insertBefore(newChild, oldChild, true)\n\n    // Destroy the oldChild\n    //   - cleanRef: true (Need to clean eventSource, because the oldChild was detached from the DOM tree)\n    //   - update: false (No need to update parent.childNodes, because replace will not cause the parent.childNodes being reordered)\n    oldChild.remove({ doUpdate: false })\n\n    return oldChild\n  }\n\n  /**\n   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild\n   * @scenario\n   * [A,B,C]\n   *   1. remove A or B\n   *   2. remove C\n   */\n  public removeChild<T extends TaroNode> (child: T, options: RemoveChildOptions = {}): T {\n    const { cleanRef, doUpdate } = options\n\n    if (cleanRef !== false && doUpdate !== false) {\n      // appendChild/replaceChild/insertBefore 不应该触发\n      // @Todo: 但其实如果 newChild 的父节点是另一颗子树的节点，应该是要触发的\n      MutationObserver.record({\n        type: MutationRecordType.CHILD_LIST,\n        target: this,\n        removedNodes: [child],\n        nextSibling: child.nextSibling,\n        previousSibling: child.previousSibling\n      })\n    }\n\n    // Data Structure\n    const index = this.findIndex(child)\n    this.childNodes.splice(index, 1)\n    child.parentNode = null\n\n    // Set eventSource\n    if (cleanRef !== false) {\n      eventSource.removeNodeTree(child)\n    }\n\n    // Serialization\n    if (this._root && doUpdate !== false) {\n      this.updateChildNodes()\n    }\n\n    return child\n  }\n\n  public remove (options?: RemoveChildOptions) {\n    this.parentNode?.removeChild(this, options)\n  }\n\n  public hasChildNodes () {\n    return this.childNodes.length > 0\n  }\n\n  public enqueueUpdate (payload: UpdatePayload) {\n    this._root?.enqueueUpdate(payload)\n  }\n\n  public get ownerDocument (): TaroDocument {\n    return env.document\n  }\n\n  static extend (methodName: string, options: TFunc | Record<string, any>) {\n    extend(TaroNode, methodName, options)\n  }\n}\n"],"mappings":"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"}