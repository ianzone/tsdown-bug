{"version":3,"file":"parser.js","names":["tagName: string","stack: Element[]","tagParents: undefined | string[]","tag: string","str: string","children: ChildNode[]","document: TaroDocument","styleOptions: {\n    styleTagParser: StyleTagParser\n    descendantList: number[]\n  }","parent?: TaroElement","child: Text | Element","el: ParsedTaroElement","html: string","root: Element","state: State","attributes: string[]","attrToken: Token","children: Element[]","element: Element","innerState: State"],"sources":["../../../src/dom-external/inner-html/parser.ts"],"sourcesContent":["import { isFunction } from '@tarojs/shared'\n\nimport { options } from '../../options'\nimport { Scaner, Token } from './scaner'\nimport StyleTagParser from './style'\nimport { isBlockElements, isInlineElements, isMiniElements, specialMiniElements } from './tags'\nimport { unquote } from './utils'\n\nimport type { TaroDocument } from '../../dom/document'\nimport type { TaroElement } from '../../dom/element'\n\ninterface State {\n  tokens: Token[]\n  cursor: number\n  stack: Element[]\n}\n\nconst closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n}\n\ninterface Node {\n  type: string\n}\n\ninterface Comment extends Node {\n  type: 'comment'\n  content: string\n}\n\nexport interface Text extends Node {\n  type: 'text'\n  content: string\n}\n\nexport interface Element extends Node {\n  type: 'element'\n  tagName: string\n  children: ChildNode[]\n  attributes: string[]\n}\n\nexport interface ParsedTaroElement extends TaroElement{\n  h5tagName?: string\n}\n\ntype ChildNode = Comment | Text | Element\n\nfunction hasTerminalParent (tagName: string, stack: Element[]) {\n  const tagParents: undefined | string[] = closingTagAncestorBreakers[tagName]\n  if (tagParents) {\n    let currentIndex = stack.length - 1\n    while (currentIndex >= 0) {\n      const parentTagName = stack[currentIndex].tagName\n      if (parentTagName === tagName) {\n        break\n      }\n      if (tagParents && tagParents.includes(parentTagName!)) {\n        return true\n      }\n      currentIndex--\n    }\n  }\n  return false\n}\n\nfunction getTagName (tag: string) {\n  if (options.html!.renderHTMLTag) {\n    return tag\n  }\n\n  if (specialMiniElements[tag]) {\n    return specialMiniElements[tag]\n  } else if (isMiniElements(tag)) {\n    return tag\n  } else if (isBlockElements(tag)) {\n    return 'view'\n  } else if (isInlineElements(tag)) {\n    return 'text'\n  }\n\n  return 'view'\n}\n\nfunction splitEqual (str: string) {\n  const sep = '='\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  const key = str.slice(0, idx).trim()\n  const value = str.slice(idx + sep.length).trim()\n  return [key, value]\n}\n\nfunction format (\n  children: ChildNode[],\n  document: TaroDocument,\n  styleOptions: {\n    styleTagParser: StyleTagParser\n    descendantList: number[]\n  },\n  parent?: TaroElement\n) {\n  return children\n    .filter(child => {\n      // 过滤注释和空文本节点\n      if (child.type === 'comment') {\n        return false\n      } else if (child.type === 'text') {\n        return child.content !== ''\n      }\n      return true\n    })\n    .map((child: Text | Element) => {\n      // 文本节点\n      if (child.type === 'text') {\n        let text = document.createTextNode(child.content)\n        if (isFunction(options.html!.transformText)) {\n          text = options.html!.transformText(text, child)\n        }\n        parent?.appendChild(text)\n        return text\n      }\n\n      const el: ParsedTaroElement = document.createElement(getTagName(child.tagName))\n      el.h5tagName = child.tagName\n\n      parent?.appendChild(el)\n\n      if (!options.html!.renderHTMLTag) {\n        el.className = `h5-${child.tagName}`\n      }\n\n      for (let i = 0; i < child.attributes.length; i++) {\n        const attr = child.attributes[i]\n        const [key, value] = splitEqual(attr)\n        if (key === 'class') {\n          el.className += ' ' + unquote(value)\n        } else if (key[0] === 'o' && key[1] === 'n') {\n          continue\n        } else {\n          el.setAttribute(key, value == null ? true : unquote(value))\n        }\n      }\n\n      const { styleTagParser, descendantList } = styleOptions\n      const list = descendantList.slice()\n      const style = styleTagParser.matchStyle(child.tagName, el, list)\n\n      el.setAttribute('style', style + el.style.cssText)\n      // console.log('style, ', style)\n\n      format(child.children, document, {\n        styleTagParser,\n        descendantList: list\n      }, el)\n\n      if (isFunction(options.html!.transformElement)) {\n        return options.html!.transformElement(el, child)\n      }\n\n      return el\n    })\n}\n\nexport function parser (html: string, document: TaroDocument) {\n  const styleTagParser = new StyleTagParser()\n  html = styleTagParser.extractStyle(html)\n\n  const tokens = new Scaner(html).scan()\n\n  const root: Element = { tagName: '', children: [], type: 'element', attributes: [] }\n\n  const state = { tokens, options, cursor: 0, stack: [root] }\n  parse(state)\n\n  return format(root.children, document, {\n    styleTagParser,\n    descendantList: Array(styleTagParser.styles.length).fill(0)\n  })\n}\n\nfunction parse (state: State) {\n  const { tokens, stack } = state\n  let { cursor } = state\n\n  const len = tokens.length\n\n  let nodes = stack[stack.length - 1].children\n\n  while (cursor < len) {\n    const token = tokens[cursor]\n    if (token.type !== 'tag-start') {\n      // comment or text\n      nodes.push(token as ChildNode)\n      cursor++\n      continue\n    }\n\n    const tagToken = tokens[++cursor]\n    cursor++\n    const tagName = tagToken.content!.toLowerCase()\n    if (token.close) {\n      let index = stack.length\n      let shouldRewind = false\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          shouldRewind = true\n          break\n        }\n      }\n      while (cursor < len) {\n        const endToken = tokens[cursor]\n        if (endToken.type !== 'tag-end') break\n        cursor++\n      }\n      if (shouldRewind) {\n        stack.splice(index)\n        break\n      } else {\n        continue\n      }\n    }\n\n    const isClosingTag = options.html!.closingElements.has(tagName)\n    let shouldRewindToAutoClose = isClosingTag\n    if (shouldRewindToAutoClose) {\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack)\n    }\n\n    if (shouldRewindToAutoClose) {\n      let currentIndex = stack.length - 1\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack.splice(currentIndex)\n          const previousIndex = currentIndex - 1\n          nodes = stack[previousIndex].children\n          break\n        }\n        currentIndex = currentIndex - 1\n      }\n    }\n\n    const attributes: string[] = []\n    let attrToken: Token\n    while (cursor < len) {\n      attrToken = tokens[cursor]\n      if (attrToken.type === 'tag-end') break\n      attributes.push(attrToken.content!)\n      cursor++\n    }\n\n    cursor++\n    const children: Element[] = []\n    const element: Element = {\n      type: 'element',\n      tagName: tagToken.content!,\n      attributes,\n      children\n    }\n    nodes.push(element)\n\n    const hasChildren = !(attrToken!.close || options.html!.voidElements.has(tagName))\n    if (hasChildren) {\n      stack.push({ tagName, children } as any)\n      const innerState: State = { tokens, cursor, stack }\n      parse(innerState)\n      cursor = innerState.cursor\n    }\n  }\n\n  state.cursor = cursor\n}\n"],"mappings":"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"}