{"version":3,"file":"scaner.js","names":["position: Position","str: string","len: number","end: number","char: string","tagName: string","index: number","cursor: number","wordBegin: number","html: string","quote: string | null","words: string[]","newWord"],"sources":["../../../src/dom-external/inner-html/scaner.ts"],"sourcesContent":["import { options } from '../../options'\n\ninterface Position {\n  index: number\n  column: number\n  line: number\n}\n\nexport interface Token {\n  type: string\n  content?: string\n  position?: {\n    start?: Position\n    end?: Position\n  }\n  close?: boolean\n}\n\nfunction initPosition (): Position {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  }\n}\n\nfunction feedPosition (position: Position, str: string, len: number) {\n  const start = position.index\n  const end = position.index = start + len\n  for (let i = start; i < end; i++) {\n    const char = str.charAt(i)\n    if (char === '\\n') {\n      position.line++\n      position.column = 0\n    } else {\n      position.column++\n    }\n  }\n}\n\nfunction jumpPosition (position: Position, str: string, end: number) {\n  const len = end - position.index\n  return feedPosition(position, str, len)\n}\n\nfunction copyPosition (position: Position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  }\n}\n\nconst whitespace = /\\s/\nfunction isWhitespaceChar (char: string) {\n  return whitespace.test(char)\n}\n\nconst equalSign = /=/\nfunction isEqualSignChar (char: string) {\n  return equalSign.test(char)\n}\n\nfunction shouldBeIgnore (tagName: string) {\n  const name = tagName.toLowerCase()\n  if (options.html!.skipElements.has(name)) {\n    return true\n  }\n  return false\n}\n\nconst alphanumeric = /[A-Za-z0-9]/\n\nfunction findTextEnd (str: string, index: number) {\n  while (true) {\n    const textEnd = str.indexOf('<', index)\n    if (textEnd === -1) {\n      return textEnd\n    }\n    const char = str.charAt(textEnd + 1)\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd\n    }\n    index = textEnd + 1\n  }\n}\n\nfunction isWordEnd (cursor: number, wordBegin: number, html: string) {\n  if (!isWhitespaceChar(html.charAt(cursor))) return false\n\n  const len = html.length\n\n  // backwrad\n  for (let i = cursor - 1; i > wordBegin; i--) {\n    const char = html.charAt(i)\n    if (!isWhitespaceChar(char)) {\n      if (isEqualSignChar(char)) return false\n      break\n    }\n  }\n\n  // forward\n  for (let i = cursor + 1; i < len; i++) {\n    const char = html.charAt(i)\n    if (!isWhitespaceChar(char)) {\n      if (isEqualSignChar(char)) return false\n      return true\n    }\n  }\n}\n\nexport class Scaner {\n  private tokens: Token[] = []\n\n  private position: Position = initPosition()\n\n  private html: string\n\n  constructor (html: string) {\n    this.html = html\n  }\n\n  public scan (): Token[] {\n    const { html, position } = this\n    const len = html.length\n\n    while (position.index < len) {\n      const start = position.index\n      this.scanText()\n      if (position.index === start) {\n        const isComment = html.startsWith('!--', start + 1)\n        if (isComment) {\n          this.scanComment()\n        } else {\n          const tagName = this.scanTag()\n          if (shouldBeIgnore(tagName)) {\n            this.scanSkipTag(tagName)\n          }\n        }\n      }\n    }\n\n    return this.tokens\n  }\n\n  private scanText () {\n    const type = 'text'\n    const { html, position } = this\n    let textEnd = findTextEnd(html, position.index)\n    if (textEnd === position.index) {\n      return\n    }\n    if (textEnd === -1) {\n      textEnd = html.length\n    }\n\n    const start = copyPosition(position)\n    const content = html.slice(position.index, textEnd)\n    jumpPosition(position, html, textEnd)\n    const end = copyPosition(position)\n    this.tokens.push({ type, content, position: { start, end } })\n  }\n\n  private scanComment () {\n    const type = 'comment'\n    const { html, position } = this\n    const start = copyPosition(position)\n    feedPosition(position, html, 4) // \"<!--\".length\n    let contentEnd = html.indexOf('-->', position.index)\n    let commentEnd = contentEnd + 3 // \"-->\".length\n    if (contentEnd === -1) {\n      contentEnd = commentEnd = html.length\n    }\n\n    const content = html.slice(position.index, contentEnd)\n    jumpPosition(position, html, commentEnd)\n    this.tokens.push({\n      type,\n      content,\n      position: {\n        start,\n        end: copyPosition(position)\n      }\n    })\n  }\n\n  private scanTag () {\n    this.scanTagStart()\n    const tagName = this.scanTagName()\n    this.scanAttrs()\n    this.scanTagEnd()\n\n    return tagName\n  }\n\n  private scanTagStart () {\n    const type = 'tag-start'\n    const { html, position } = this\n\n    const secondChar = html.charAt(position.index + 1)\n    const close = secondChar === '/'\n    const start = copyPosition(position)\n    feedPosition(position, html, close ? 2 : 1)\n    this.tokens.push({ type, close, position: { start } })\n  }\n\n  private scanTagEnd () {\n    const type = 'tag-end'\n    const { html, position } = this\n\n    const firstChar = html.charAt(position.index)\n    const close = firstChar === '/'\n    feedPosition(position, html, close ? 2 : 1)\n    const end = copyPosition(position)\n    this.tokens.push({ type, close, position: { end } })\n  }\n\n  private scanTagName (): string {\n    const type = 'tag'\n    const { html, position } = this\n    const len = html.length\n    let start = position.index\n    while (start < len) {\n      const char = html.charAt(start)\n      const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n      if (isTagChar) break\n      start++\n    }\n\n    let end = start + 1\n    while (end < len) {\n      const char = html.charAt(end)\n      const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n      if (!isTagChar) break\n      end++\n    }\n\n    jumpPosition(position, html, end)\n    const tagName = html.slice(start, end)\n    this.tokens.push({\n      type,\n      content: tagName\n    })\n\n    return tagName\n  }\n\n  private scanAttrs () {\n    const { html, position, tokens } = this\n    let cursor = position.index\n    let quote: string | null = null // null, single-, or double-quote\n    let wordBegin = cursor // index of word start\n    const words: string[] = [] // \"key\", \"key=value\", \"key='value'\", etc\n    const len = html.length\n    while (cursor < len) {\n      const char = html.charAt(cursor)\n      if (quote) {\n        const isQuoteEnd = char === quote\n        if (isQuoteEnd) {\n          quote = null\n        }\n        cursor++\n        continue\n      }\n\n      const isTagEnd = char === '/' || char === '>'\n      if (isTagEnd) {\n        if (cursor !== wordBegin) {\n          words.push(html.slice(wordBegin, cursor))\n        }\n        break\n      }\n\n      if (isWordEnd(cursor, wordBegin, html)) {\n        if (cursor !== wordBegin) {\n          words.push(html.slice(wordBegin, cursor))\n        }\n        wordBegin = cursor + 1\n        cursor++\n        continue\n      }\n\n      const isQuoteStart = char === '\\'' || char === '\"'\n      if (isQuoteStart) {\n        quote = char\n        cursor++\n        continue\n      }\n\n      cursor++\n    }\n\n    jumpPosition(position, html, cursor)\n\n    const wLen = words.length\n    const type = 'attribute'\n    for (let i = 0; i < wLen; i++) {\n      const word = words[i]\n      const isNotPair = word.includes('=')\n      if (isNotPair) {\n        const secondWord = words[i + 1]\n        if (secondWord && secondWord.startsWith('=')) {\n          if (secondWord.length > 1) {\n            const newWord = word + secondWord\n            tokens.push({ type, content: newWord })\n            i += 1\n            continue\n          }\n          const thirdWord = words[i + 2]\n          i += 1\n          if (thirdWord) {\n            const newWord = word + '=' + thirdWord\n            tokens.push({ type, content: newWord })\n            i += 1\n            continue\n          }\n        }\n      }\n      if (word.endsWith('=')) {\n        const secondWord = words[i + 1]\n        if (secondWord && !secondWord.includes('=')) {\n          const newWord = word + secondWord\n          tokens.push({ type, content: newWord })\n          i += 1\n          continue\n        }\n\n        const newWord = word.slice(0, -1)\n        tokens.push({ type, content: newWord })\n        continue\n      }\n\n      tokens.push({ type, content: word })\n    }\n  }\n\n  private scanSkipTag (tagName: string) {\n    const { html, position } = this\n    const safeTagName = tagName.toLowerCase()\n    const len = html.length\n    while (position.index < len) {\n      const nextTag = html.indexOf('</', position.index)\n      if (nextTag === -1) {\n        this.scanText()\n        break\n      }\n\n      jumpPosition(position, html, nextTag)\n      const name = this.scanTag()\n      if (safeTagName === name.toLowerCase()) {\n        break\n      }\n    }\n  }\n}\n"],"mappings":"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"}