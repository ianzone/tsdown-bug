{"version":3,"file":"implements.js","names":["observers: MutationObserverImpl[]","callback: MutationCallback","target: TaroNode","options?: MutationObserverInit","observerTarget: TaroNode | null","target: TaroNode | null","record: MutationRecord","options: MutationObserverInit","observer: MutationObserverImpl","t: TaroNode | null"],"sources":["../../../src/dom-external/mutation-observer/implements.ts"],"sourcesContent":["import { MutationRecordType } from './record'\n\nimport type { TaroNode } from '../../dom/node'\nimport type { MutationRecord } from './record'\n\nexport type MutationCallback = (mutations: MutationRecord[]) => any\n\n/**\n * @see https://dom.spec.whatwg.org/#dictdef-mutationobserverinit\n */\nexport interface MutationObserverInit {\n  attributeFilter?: string[]\n  attributeOldValue?: boolean\n  attributes?: boolean\n  characterData?: boolean\n  characterDataOldValue?: boolean\n  childList?: boolean\n  subtree?: boolean\n}\n\nconst observers: MutationObserverImpl[] = []\n\n/**\n * The MutationObserver provides the ability\n * to watch for changes being made to the DOM tree.\n * It will invoke a specified callback function\n * when DOM changes occur.\n * @see https://dom.spec.whatwg.org/#mutationobserver\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n */\nexport class MutationObserverImpl {\n  public callback: MutationCallback\n  public target: TaroNode | null\n  public options: MutationObserverInit\n  public records: MutationRecord[] = []\n\n  constructor (callback: MutationCallback) {\n    this.callback = callback\n  }\n\n  /**\n   * Configures the MutationObserver\n   * to begin receiving notifications\n   * through its callback function\n   * when DOM changes matching the given options occur.\n   *\n   * Options matching is to be implemented.\n   */\n  observe (target: TaroNode, options?: MutationObserverInit): void {\n    this.disconnect()\n    this.target = target\n    this.options = options || {}\n\n    observers.push(this)\n  }\n\n  /**\n   * Stop the MutationObserver instance\n   * from receiving further notifications\n   * until and unless observe() is called again.\n   */\n  disconnect (): void {\n    this.target = null\n\n    const index = observers.indexOf(this)\n    if (index >= 0) {\n      observers.splice(index, 1)\n    }\n  }\n\n  /**\n   * Removes all pending notifications\n   * from the MutationObserver's notification queue\n   * and returns them in a new Array of MutationRecord objects.\n   */\n  takeRecords (): MutationRecord[] {\n    return this.records.splice(0, this.records.length)\n  }\n}\n\n/** Match two TaroNodes by sid. */\nconst sidMatches = (\n  observerTarget: TaroNode | null,\n  target: TaroNode | null\n): boolean => {\n  return !!observerTarget && observerTarget.sid === target?.sid\n}\n\nconst isConcerned = (record: MutationRecord, options: MutationObserverInit) => {\n  const { characterData, characterDataOldValue, attributes, attributeOldValue, childList } = options\n  switch (record.type) {\n    case MutationRecordType.CHARACTER_DATA:\n      if (characterData) {\n        if (!characterDataOldValue) record.oldValue = null\n        return true\n      }\n      return false\n    case MutationRecordType.ATTRIBUTES:\n      if (attributes) {\n        if (!attributeOldValue) record.oldValue = null\n        return true\n      }\n      return false\n    case MutationRecordType.CHILD_LIST:\n      if (childList) {\n        return true\n      }\n      return false\n  }\n}\n\nlet pendingMuatations = false\n\nfunction logMutation (observer: MutationObserverImpl, record: MutationRecord) {\n  observer.records.push(record)\n  if (!pendingMuatations) {\n    pendingMuatations = true\n    Promise\n      .resolve()\n      .then(() => {\n        pendingMuatations = false\n        observers.forEach(observer => {\n          return observer.callback(observer.takeRecords())\n        })\n      })\n  }\n}\n\nexport function recordMutation (record: MutationRecord) {\n  observers.forEach(observer => {\n    const { options } = observer\n    for (let t: TaroNode | null = record.target; t; t = t.parentNode) {\n      if (sidMatches(observer.target, t) && isConcerned(record, options)) {\n        logMutation(observer, record)\n        break\n      }\n      if (!options.subtree) break\n    }\n  })\n}\n"],"mappings":";;;AAoBA,MAAMA,YAAoC,CAAE;;;;;;;;;AAU5C,IAAa,uBAAb,MAAkC;CAChC,AAAO;CACP,AAAO;CACP,AAAO;CACP,AAAO,UAA4B,CAAE;CAErC,YAAaC,UAA4B;AACvC,OAAK,WAAW;CACjB;;;;;;;;;CAUD,QAASC,QAAkBC,SAAsC;AAC/D,OAAK,YAAY;AACjB,OAAK,SAAS;AACd,OAAK,UAAU,WAAW,CAAE;AAE5B,YAAU,KAAK,KAAK;CACrB;;;;;;CAOD,aAAoB;AAClB,OAAK,SAAS;EAEd,MAAM,QAAQ,UAAU,QAAQ,KAAK;AACrC,MAAI,SAAS,GAAG;AACd,aAAU,OAAO,OAAO,EAAE;EAC3B;CACF;;;;;;CAOD,cAAiC;AAC/B,SAAO,KAAK,QAAQ,OAAO,GAAG,KAAK,QAAQ,OAAO;CACnD;AACF;;AAGD,MAAM,aAAa,CACjBC,gBACAC,WACY;AACZ,UAAS,kBAAkB,eAAe,QAAQ,QAAQ;AAC3D;AAED,MAAM,cAAc,CAACC,QAAwBC,YAAkC;CAC7E,MAAM,EAAE,eAAe,uBAAuB,YAAY,mBAAmB,WAAW,GAAG;AAC3F,SAAQ,OAAO,MAAf;EACE,KAAK,mBAAmB;AACtB,OAAI,eAAe;AACjB,SAAK,sBAAuB,QAAO,WAAW;AAC9C,WAAO;GACR;AACD,UAAO;EACT,KAAK,mBAAmB;AACtB,OAAI,YAAY;AACd,SAAK,kBAAmB,QAAO,WAAW;AAC1C,WAAO;GACR;AACD,UAAO;EACT,KAAK,mBAAmB;AACtB,OAAI,WAAW;AACb,WAAO;GACR;AACD,UAAO;CACV;AACF;AAED,IAAI,oBAAoB;AAExB,SAAS,YAAaC,UAAgCF,QAAwB;AAC5E,UAAS,QAAQ,KAAK,OAAO;AAC7B,MAAK,mBAAmB;AACtB,sBAAoB;AACpB,UACG,SAAS,CACT,KAAK,MAAM;AACV,uBAAoB;AACpB,aAAU,QAAQ,gBAAY;AAC5B,WAAO,WAAS,SAAS,WAAS,aAAa,CAAC;GACjD,EAAC;EACH,EAAC;CACL;AACF;AAED,SAAgB,eAAgBA,QAAwB;AACtD,WAAU,QAAQ,cAAY;EAC5B,MAAM,EAAE,SAAS,GAAG;AACpB,OAAK,IAAIG,IAAqB,OAAO,QAAQ,GAAG,IAAI,EAAE,YAAY;AAChE,OAAI,WAAW,SAAS,QAAQ,EAAE,IAAI,YAAY,QAAQ,QAAQ,EAAE;AAClE,gBAAY,UAAU,OAAO;AAC7B;GACD;AACD,QAAK,QAAQ,QAAS;EACvB;CACF,EAAC;AACH"}