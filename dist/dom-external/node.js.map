{"version":3,"file":"node.js","names":["position: IPosition","html: string","value: any","node: TaroNode & { id?: string }"],"sources":["../../src/dom-external/node.ts"],"sourcesContent":["import { DATASET, OBJECT, PROPS, STYLE } from '../constants'\nimport { NodeType } from '../dom/node_types'\nimport { parser } from '../dom-external/inner-html/parser'\n\nimport type { TaroNode } from '../dom/node'\n\nexport type IPosition = 'beforebegin' | 'afterbegin' | 'beforeend' | 'afterend'\n\n/**\n * An implementation of `Element.insertAdjacentHTML()`\n * to support Vue 3 with a version of or greater than `vue@3.1.2`\n */\nexport function insertAdjacentHTML (\n  this: TaroNode,\n  position: IPosition,\n  html: string\n) {\n  const parsedNodes = parser(html, this.ownerDocument)\n\n  for (let i = 0; i < parsedNodes.length; i++) {\n    const n = parsedNodes[i]\n\n    switch (position) {\n      case 'beforebegin':\n        this.parentNode?.insertBefore(n, this)\n        break\n      case 'afterbegin':\n        if (this.hasChildNodes()) {\n          this.insertBefore(n, this.childNodes[0])\n        } else {\n          this.appendChild(n)\n        }\n        break\n      case 'beforeend':\n        this.appendChild(n)\n        break\n      case 'afterend':\n        this.parentNode?.appendChild(n)\n        break\n    }\n  }\n}\n\nexport function cloneNode (this: TaroNode, isDeep = false) {\n  const document = this.ownerDocument\n  let newNode\n\n  if (this.nodeType === NodeType.ELEMENT_NODE) {\n    newNode = document.createElement(this.nodeName)\n  } else if (this.nodeType === NodeType.TEXT_NODE) {\n    newNode = document.createTextNode('')\n  }\n\n  for (const key in this) {\n    const value: any = this[key]\n    // eslint-disable-next-line valid-typeof\n    if ([PROPS, DATASET].includes(key) && typeof value === OBJECT) {\n      newNode[key] = { ...value }\n    } else if (key === '_value') {\n      newNode[key] = value\n    } else if (key === STYLE) {\n      newNode.style._value = { ...value._value }\n      newNode.style._usedStyleProp = new Set(Array.from(value._usedStyleProp))\n    }\n  }\n\n  if (isDeep) {\n    newNode.childNodes = this.childNodes.map(node => (node as any).cloneNode(true))\n  }\n\n  return newNode\n}\n\nexport function contains (this: TaroNode, node: TaroNode & { id?: string }): boolean {\n  let isContains = false\n  this.childNodes.some(childNode => {\n    const { uid } = childNode\n    if (uid === node.uid || uid === node.id || (childNode as any).contains(node)) {\n      isContains = true\n      return true\n    }\n  })\n  return isContains\n}\n"],"mappings":";;;;;;;;;AAYA,SAAgB,mBAEdA,UACAC,MACA;CACA,MAAM,cAAc,OAAO,MAAM,KAAK,cAAc;AAEpD,MAAK,IAAI,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;EAC3C,MAAM,IAAI,YAAY;AAEtB,UAAQ,UAAR;GACE,KAAK;AACH,SAAK,YAAY,aAAa,GAAG,KAAK;AACtC;GACF,KAAK;AACH,QAAI,KAAK,eAAe,EAAE;AACxB,UAAK,aAAa,GAAG,KAAK,WAAW,GAAG;IACzC,OAAM;AACL,UAAK,YAAY,EAAE;IACpB;AACD;GACF,KAAK;AACH,SAAK,YAAY,EAAE;AACnB;GACF,KAAK;AACH,SAAK,YAAY,YAAY,EAAE;AAC/B;EACH;CACF;AACF;AAED,SAAgB,UAA2B,SAAS,OAAO;CACzD,MAAM,WAAW,KAAK;CACtB,IAAI;AAEJ,KAAI,KAAK,aAAa,SAAS,cAAc;AAC3C,YAAU,SAAS,cAAc,KAAK,SAAS;CAChD,WAAU,KAAK,aAAa,SAAS,WAAW;AAC/C,YAAU,SAAS,eAAe,GAAG;CACtC;AAED,MAAK,MAAM,OAAO,MAAM;EACtB,MAAMC,QAAa,KAAK;AAExB,MAAI,CAAC,OAAO,OAAQ,EAAC,SAAS,IAAI,WAAW,UAAU,QAAQ;AAC7D,WAAQ,OAAO,EAAE,GAAG,MAAO;EAC5B,WAAU,QAAQ,UAAU;AAC3B,WAAQ,OAAO;EAChB,WAAU,QAAQ,OAAO;AACxB,WAAQ,MAAM,SAAS,EAAE,GAAG,MAAM,OAAQ;AAC1C,WAAQ,MAAM,iBAAiB,IAAI,IAAI,MAAM,KAAK,MAAM,eAAe;EACxE;CACF;AAED,KAAI,QAAQ;AACV,UAAQ,aAAa,KAAK,WAAW,IAAI,UAAQ,AAAC,KAAa,UAAU,KAAK,CAAC;CAChF;AAED,QAAO;AACR;AAED,SAAgB,SAA0BC,MAA2C;CACnF,IAAI,aAAa;AACjB,MAAK,WAAW,KAAK,eAAa;EAChC,MAAM,EAAE,KAAK,GAAG;AAChB,MAAI,QAAQ,KAAK,OAAO,QAAQ,KAAK,MAAM,AAAC,UAAkB,SAAS,KAAK,EAAE;AAC5E,gBAAa;AACb,UAAO;EACR;CACF,EAAC;AACF,QAAO;AACR"}